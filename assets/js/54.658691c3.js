(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{544:function(a,t,s){"use strict";s.r(t);var n=s(6),e=Object(n.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"多继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多继承"}},[a._v("#")]),a._v(" 多继承")]),a._v(" "),s("p",[a._v("多继承即一个类继承多个父类。在 Java 中，类不支持多继承，但是接口可以继承多个接口，同时类也可以可以实现多个接口。之所以会出现这种情况是因为 Java 只支持声明多继承，而不支持实现多继承，即可以有多个声明（接口），但是不能有多个实现（父类）。")]),a._v(" "),s("p",[a._v("可以通过 JDK8 增加的接口默认方法实现类似多继承的效果。但是也有局限性，比如无法在接口中定义非静态的字段，构造器等。")]),a._v(" "),s("h2",{attrs:{id:"接口"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#接口"}},[a._v("#")]),a._v(" 接口")]),a._v(" "),s("p",[a._v("接口不能实例化，也不能有构造方法，不能包含非常量成员。任何字段都是 public static final 的。没有非静态方法的实现（JDK8 以后的可以支持默认方法）。")]),a._v(" "),s("p",[a._v("JDK8 后增加了默认方法，可以为方法添加默认的实现。JDK8 以前只能通过抽象类实现。")]),a._v(" "),s("h2",{attrs:{id:"抽象类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#抽象类"}},[a._v("#")]),a._v(" 抽象类")]),a._v(" "),s("p",[a._v("抽象类和一般 Java 类没有特别大的区别，除了不能实例化。不能实例化，但是可以添加构造方法。可以定义抽象方法，也可以不定义。抽象类中的抽象方法必须在子类中实现。抽象类可以用来做静态工具方法的容器（不能实例化的特性）。")]),a._v(" "),s("h2",{attrs:{id:"functional-接口"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#functional-接口"}},[a._v("#")]),a._v(" Functional 接口")]),a._v(" "),s("p",[a._v("Functional 接口是 Java8 后新增的一种特性，用于支持 Lambda 语句。只有一个抽象方法的接口被成为 Functional 接口，Functional 接口可以直接使用 Lambda 语句定义实现。")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@FunctionalInterface")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("interface")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Fun")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("apply")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Main")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Fun")]),a._v(" fun "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n      "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"123"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    fun"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("apply")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br")])]),s("p",[a._v("建议使用 @FunctionalInterface 注解进行标注，但不是必须的。任何符合 Functional 接口的定义的接口都可以使用 Lambda 表达式。")]),a._v(" "),s("p",[a._v("内置接口（常用）：")]),a._v(" "),s("ul",[s("li",[a._v("Predicate：传入一个参数，返回一个 bool 结果， 方法为 boolean test(T t)")]),a._v(" "),s("li",[a._v("Consumer：传入一个参数，无返回值，纯消费。 方法为 void accept(T t)")]),a._v(" "),s("li",[a._v("Function：传入一个参数，返回一个结果，方法为 R apply(T t)")]),a._v(" "),s("li",[a._v("Supplier：无参数传入，返回一个结果，方法为 T get()")]),a._v(" "),s("li",[a._v("UnaryOperator：一元操作符， 继承 Function,传入参数的类型和返回类型相同。")]),a._v(" "),s("li",[a._v("BinaryOperator：二元操作符， 传入的两个参数的类型和返回类型相同， 继承 BiFunction")])])])}),[],!1,null,null,null);t.default=e.exports}}]);