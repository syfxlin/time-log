(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{521:function(t,r,e){"use strict";e.r(r);var s=e(6),n=Object(s.a)({},(function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[t._v("#")]),t._v(" 介绍")]),t._v(" "),e("p",[e("strong",[t._v("意图")]),t._v("：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。")]),t._v(" "),e("p",[e("strong",[t._v("主要解决问题")]),t._v("：对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。")]),t._v(" "),e("p",[e("strong",[t._v("实现方式")]),t._v("：将各种具体的状态类抽象出来。")]),t._v(" "),e("p",[e("strong",[t._v("关键代码")]),t._v("：通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if...else 等条件选择语句。")]),t._v(" "),e("p",[e("strong",[t._v("优点")]),t._v("：1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。")]),t._v(" "),e("p",[e("strong",[t._v("缺点")]),t._v('：1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对"开闭原则"的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。')]),t._v(" "),e("p",[e("strong",[t._v("使用场景")]),t._v("：1、行为随状态改变而改变的场景。 2、条件、分支语句的代替者。")]),t._v(" "),e("h2",{attrs:{id:"代码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代码"}},[t._v("#")]),t._v(" 代码")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/syfxlin/code/blob/master/design-pattern-java/src/main/java/me/ixk/design_pattern/state",target:"_blank",rel:"noopener noreferrer"}},[t._v("代码"),e("OutboundLink")],1)])])}),[],!1,null,null,null);r.default=n.exports}}]);