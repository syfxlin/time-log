---
title: 垃圾回收
date: 2020-12-09
categories:
  - Java
tags:
  - 概念
---

## 垃圾识别机制

### 引用计数

给每个对象添加一个引用计数器，每当有其他的对象引用了这个对象，就把引用计数器的值+1，如果一个对象的引用计数为 0 则说明没有对象引用它。

缺点：互相引用的时候会导致引用计数始终无法唯一。

### 可达性分析

可达性分析可以理解为一棵树的遍历，根节点是一个对象，而其子节点是引用了当前对象的对象。从根节点开始做遍历，如果发现从所有根节点出发的遍历都已经完成了，但是仍然有对象没有被访问到，那么说明这些对象是不可用的，需要将内存回收掉。

可以做根节点（GC Roots）的资源：

- 栈帧中的局部变量所引用的对象
- 本地方法栈所引用的对象
- 方法区中常量所引用的对象
- 方法区中类静态属性所引用的对象

## 回收算法

### 标记-清除

**过程**：首先标记出所有需要回收的对象，然后统一对标记的对象进行回收。

**缺点**：会产生大量的内存碎片。虽然总体看起来还有足够的剩余内存空间，但是他们都是以一块很小的内存分散在各个地方。如果此时需要为一个大对象申请空间，即使总体上的内存空间足够，但是 JVM 无法找到一块这么大的连续内存空间，就会导致触发一次 GC。

![标记-清除回收图](https://cdn.jsdelivr.net/gh/syfxlin/pic/2020/12/20201209194321.png)

### 复制

**过程**：将现有的内存空间分为两半 A 和 B，所有的新对象的内存都在 A 中分配，然后当 A 用完了之后，就开始对象存活判断，将 A 中还存活的对象复制到 B 去，然后一次性将 A 中的内存空间回收掉。

**缺点**：由于把内存分了区，所以内存空间会缩小指定比例。

![复制回收图](https://cdn.jsdelivr.net/gh/syfxlin/pic/2020/12/20201209194415.png)

### 标记-整理

**过程**：和标记-清除类似，只不过在清除后会对存活的对象进行整理，这样就解决了内存碎片的问题。

![标记-整理回收图](https://cdn.jsdelivr.net/gh/syfxlin/pic/2020/12/20201209194456.png)

### 分代收集

针对不同的内存区域使用不同的内存收集算法，充分利用不同回收算法的优点。

## 相关概率

### 吞吐量、短停顿

**高吞吐量**：GC 的总时间越短，系统的吞吐量则越高。换句话说，高吞吐量则意味着，STW 的时间可能会比正常的时间多一点，也就更加适合那种不存在太多交互的后台的系统，因为对实时性的要求不是很高，就可以高效率的完成任务。

**短停顿时间**：STW 的时间短，则说明对系统的响应速度要求很高，因为要跟用户频繁的交互。因为低响应时间会带来较高的用户体验。

### Minor GC 和 Full GC

**新生代 GC（Minor GC）**：指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。

**老年代 GC（Major GC / Full GC）**：指发生在老年代的 GC，出现了 Major GC，经常会伴随至少一次的 Minor GC（但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程）。Major GC 的速度一般会比 Minor GC 慢 10 倍以上。

## 垃圾收集器

![垃圾收集器列表](https://cdn.jsdelivr.net/gh/syfxlin/pic/2020/12/20201209202114.png)

### Serial && Serial Old

**Serial**，用于新生代，采用复制算法，回收时采用单线程的方式，进行垃圾收集的时候需要暂停其他线程（STW）。 一般用于 Client 端的 JVM。

**Serial Old**，用于老生代，采用标记整理算法，回收时采用单线程的方式。进行垃圾收集的时候需要暂停其他线程（STW）。

![Serial && Serial Old 回收进程图](https://cdn.jsdelivr.net/gh/syfxlin/pic/2020/12/20201209194813.png)

### ParNew

**ParNew**，用于新生代，采用复制算法，回收时采用多线程的方式，进行垃圾收集的时候会暂停其他线程。

![ParNew 回收进程图](https://cdn.jsdelivr.net/gh/syfxlin/pic/2020/12/20201209195124.png)

### Parallel Scavenge & Parallel Old

**Parallel Scavenge**，用于新生代，采用复制算法，回收时采用多线程的方式，进行垃圾收集时会暂停其他线程。重视吞吐量。

**Parallel Old**，用于老生代，采用标记-整理算法，回收时采用多线程方式，进行垃圾收集时会暂停其他线程。重视吞吐量。

![Parallel Scavenge & Parallel Old 回收进程图](https://cdn.jsdelivr.net/gh/syfxlin/pic/2020/12/20201209195731.png)

### CMS（Concurrent Mark Sweep）

**CMS**，用于老生代，采用标记-清除算法，回收时混合使用单/多线程，标记时需要暂停其他线程，清除时不需要暂停其他线程。注重最低的 STW。

**回收步骤**：

1. **初始标记**：标记一下 GC Roots 能直接关联到的对象，需要 STW，速度很快。
2. **并发标记**：进行 GC Roots 跟踪的过程，耗时最长，不过无需 STW。
3. **重新标记**：暂停其他线程（STW），不过可以并发处理，修正并发标记期间因其他线程续运作而导致标记产生变动。速度较快。
4. **并发清除**：实际进行内存清理，无需 STW。

![CMS 回收进程图](https://cdn.jsdelivr.net/gh/syfxlin/pic/2020/12/20201209200031.png)

### G1

**G1**，可同时用于新生代和老生代，整体上看采用标记-整理算法，局部上看采用复制算法。当今收集器技术发展最前沿的成果之一，实现高吞吐的同时，尽可能的减少 STW 的时间。

**回收步骤**：

1. **初始标记**：标记一下 GC Roots 能直接关联到的对象，需要 STW，速度很快。
2. **并发标记**：进行 GC Roots 跟踪的过程，耗时最长，不过无需 STW。
3. **最终标记**：暂停其他线程（STW），不过可以并发处理，修正并发标记期间因其他线程续运作而导致标记产生变动。速度较快。
4. **筛选回收**：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

**原理**：

G1 垃圾收集器都会把连续的堆内存空间分为新生代、老年代，新生代则被划分的更加的细，有 Eden 和两个较小的 Survivor 空间，而且都是连续的内存空间。而 G1 则与众不同，它引入了新的概念，叫 Region。
Region 是一堆大小相等但是不连续的内存空间，同样是采用了分代的思想，但是不存在其他的收集器的物理隔离，属于新生代和老年代的 region 分布在堆的各个地方。
Region 是一堆大小相等但是不连续的内存空间，同样是采用了分代的思想，但是不存在其他的收集器的物理隔离，属于新生代和老年代的 region 分布在堆的各个地方。

![G1 内存分布](https://cdn.jsdelivr.net/gh/syfxlin/pic/2020/12/20201209202027.png)

上面 H 则代表大对象，也叫 Humongous Object。为了防止大对象的频繁拷贝，会直接的将其放入老年代。

### ZGC

ZGC 是 JDK11 新推出的一款低延迟垃圾回收器，和 G1 类似，ZGC 也采用了标记-复制算法，同样也对堆进行 region 划分，ZGC 在标记、转移和重定位阶段几乎都是并发的，这是 ZGC 实现停顿时间小于 10ms 目标的最关键原因。ZGC 的 STW 只依赖于 GC Roots，停顿时间不会随着堆的大小或者活跃对象的大小而增加。

**回收步骤**：

1. 初始化：ZGC 初始化之后，整个内存空间的地址视图被设置为 Remapped。程序正常运行，在内存中分配对象，满足一定条件后垃圾回收启动，此时进入标记阶段。
2. 并发标记阶段：第一次进入标记阶段时视图为 M0，如果对象被 GC 标记线程或者应用线程访问过，那么就将对象的地址视图从 Remapped 调整为 M0。所以，在标记阶段结束之后，对象的地址要么是 M0 视图，要么是 Remapped。如果对象的地址是 M0 视图，那么说明对象是活跃的；如果对象的地址是 Remapped 视图，说明对象是不活跃的。
3. 并发转移阶段：标记结束后就进入转移阶段，此时地址视图再次被设置为 Remapped。如果对象被 GC 转移线程或者应用线程访问过，那么就将对象的地址视图从 M0 调整为 Remapped。

![ZGC 回收线程图](https://cdn.jsdelivr.net/gh/syfxlin/pic/2020/12/20201222103341.png)

![ZGC 回收阶段图](https://cdn.jsdelivr.net/gh/syfxlin/pic/2020/12/20201222102429.png)

**关键技术**：

ZGC 通过读屏障和着色指针，解决转移过程中准确访问对象的问题，做到了并发转移。

由于在并发 GC 中，应用程序也在不断的访问对象修改对象，而一旦 GC 变更了某个对象的地址，那么应用线程很可能就会读到旧地址，导致异常。而 ZGC 中，应用程序在读取对象时会触发读屏障，若对象被移动了，那么读屏障会把获取到的指针更新到对象的新地址上，而判断对象的地址是否更改的方式则是着色指针。
