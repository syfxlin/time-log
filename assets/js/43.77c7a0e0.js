(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{533:function(e,t,v){"use strict";v.r(t);var o=v(6),_=Object(o.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"缓存控制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存控制"}},[e._v("#")]),e._v(" 缓存控制")]),e._v(" "),v("p",[e._v("由于链路漫长，网络时延不可控，浏览器使用 HTTP 获取资源的成本较高。所以，非常有必要把 “来之不易” 的数据缓存起来，下次再请求的时候尽可能地复用。这样，就可以避免多次请求 - 应答的通信成本，节约网络带宽，也可以加快响应速度。")]),e._v(" "),v("h2",{attrs:{id:"cache-control"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[e._v("#")]),e._v(" Cache-Control")]),e._v(" "),v("p",[e._v("Cache-Control 常用的值：")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("max-age=<seconds>")]),e._v("：设置缓存存储的最大周期，超过这个时间缓存被认为过期（单位秒）。与 "),v("code",[e._v("Expires")]),e._v(" 相反，时间是相对于请求的时间。计算起点是响应报文的创建时间，即响应报文中的 "),v("code",[e._v("Date")]),e._v("。")]),e._v(" "),v("li",[v("code",[e._v("no-store")]),e._v("：不允许缓存。")]),e._v(" "),v("li",[v("code",[e._v("no-cache")]),e._v("：可以缓存数据，但是在使用前需要到服务器验证是否过期（协商缓存）。")]),e._v(" "),v("li",[v("code",[e._v("must-revalidate")]),e._v("：如果缓存不过期就可以继续使用，但过期了如果还想用就必须去服务器验证。")])]),e._v(" "),v("h2",{attrs:{id:"条件请求"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#条件请求"}},[e._v("#")]),e._v(" 条件请求")]),e._v(" "),v("p",[e._v("当需要向服务端验证缓存的时候，通常会使用条件请求的方式，向服务端发送请求，当服务端收到请求的时候会判断缓存是否过期，然后返回 "),v("code",[e._v("304 Not Modified")]),e._v(" 或者返回更新后的数据。")]),e._v(" "),v("p",[e._v("条件请求常用的头字段是 "),v("code",[e._v("If-Modified-Since")]),e._v(" 和 "),v("code",[e._v("If-None-Match")]),e._v("。需要第一次的响应报文预先提供 "),v("code",[e._v("Last-modified")]),e._v(" 和 "),v("code",[e._v("ETag")]),e._v("，然后第二次请求时就可以带上缓存里的原值，验证资源是否是最新的。如果资源没有变，服务端就响应 "),v("code",[e._v("304 Not Modified")]),e._v("，表示缓存依然有效，浏览器就可以更新一下有效期，然后继续使用该缓存。")])])}),[],!1,null,null,null);t.default=_.exports}}]);