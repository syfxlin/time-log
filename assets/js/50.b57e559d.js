(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{540:function(t,r,a){"use strict";a.r(r);var e=a(6),s=Object(e.a)({},(function(){var t=this,r=t.$createElement,a=t._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"原子类-atomic"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原子类-atomic"}},[t._v("#")]),t._v(" 原子类（Atomic）")]),t._v(" "),a("p",[t._v("原子类指的是 "),a("code",[t._v("java.util.concurrent.atomic")]),t._v(" 包下的一系列原子包装类及原子更新工具。原子类采用 CAS 来进行并发原子操作，性能相比于加锁有优势。")]),t._v(" "),a("h3",{attrs:{id:"基本类型类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本类型类"}},[t._v("#")]),t._v(" 基本类型类")]),t._v(" "),a("p",[t._v("用于通过原子的方式更新基本类型")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("AtomicBoolean")]),t._v("：原子更新布尔类型")]),t._v(" "),a("li",[a("strong",[t._v("AtomicInteger")]),t._v("：原子更新整型")]),t._v(" "),a("li",[a("strong",[t._v("AtomicLong")]),t._v("：原子更新长整型")])]),t._v(" "),a("h3",{attrs:{id:"数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[t._v("#")]),t._v(" 数组")]),t._v(" "),a("p",[t._v("通过原子的方式更新数组里的某个元素")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("AtomicIntegerArray")]),t._v("：原子更新整型数组里的元素")]),t._v(" "),a("li",[a("strong",[t._v("AtomicLongArray")]),t._v("：原子更新长整型数组里的元素")]),t._v(" "),a("li",[a("strong",[t._v("AtomicReferenceArray")]),t._v("：原子更新引用类型数组里的元素")])]),t._v(" "),a("h3",{attrs:{id:"引用类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引用类型"}},[t._v("#")]),t._v(" 引用类型")]),t._v(" "),a("p",[t._v("如果要原子的更新多个变量，就需要使用这个原子更新引用类型提供的类")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("AtomicReference")]),t._v("：原子更新引用类型")]),t._v(" "),a("li",[a("strong",[t._v("AtomicReferenceFieldUpdater")]),t._v("：原子更新引用类型里的字段")]),t._v(" "),a("li",[a("strong",[t._v("AtomicMarkableReference")]),t._v("：原子更新带有标记位的引用类型")])]),t._v(" "),a("h3",{attrs:{id:"字段类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字段类"}},[t._v("#")]),t._v(" 字段类")]),t._v(" "),a("p",[t._v("如果我们只需要某个类里的某个字段，那么就需要使用原子更新字段类")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("AtomicIntegerFieldUpdater")]),t._v("：原子更新整型的字段的更新器")]),t._v(" "),a("li",[a("strong",[t._v("AtomicLongFieldUpdater")]),t._v("：原子更新长整型字段的更新器")]),t._v(" "),a("li",[a("strong",[t._v("AtomicStampedReference")]),t._v("：原子更新带有版本号的引用类型")])]),t._v(" "),a("h3",{attrs:{id:"分段操作-striped64"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分段操作-striped64"}},[t._v("#")]),t._v(" 分段操作（Striped64）")]),t._v(" "),a("p",[t._v("Striped64 及其子类实现了分段锁的功能，将一个变量分成多段进行 CAS 操作，在高并发下，性能优于普通的原子操作类。")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("LongAccumulator")]),t._v("：原子更新长整型")]),t._v(" "),a("li",[a("strong",[t._v("LongAdder")]),t._v("：原子更新长整型")]),t._v(" "),a("li",[a("strong",[t._v("DoubleAccumulator")]),t._v("：原子更新双精度浮点型")]),t._v(" "),a("li",[a("strong",[t._v("DoubleAdder")]),t._v("：原子更新双精度浮点型")])]),t._v(" "),a("h2",{attrs:{id:"concurrenthashmap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap"}},[t._v("#")]),t._v(" ConcurrentHashMap")]),t._v(" "),a("p",[t._v("ConcurrentHashMap 采用 CAS + Synchronized 来保证并发更新的安全，底层采用数组+链表/红黑树的存储结构")]),t._v(" "),a("h3",{attrs:{id:"重要内部类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重要内部类"}},[t._v("#")]),t._v(" 重要内部类")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("Node")]),t._v("：key-value 键值对")]),t._v(" "),a("li",[a("strong",[t._v("TreeNode")]),t._v("：红黑树节点")]),t._v(" "),a("li",[a("strong",[t._v("TreeBin")]),t._v("：就相当于一颗红黑树，其构造方法其实就是构造红黑树的过程")]),t._v(" "),a("li",[a("strong",[t._v("ForwardingNode")]),t._v("：辅助节点，用于 ConcurrentHashMap 扩容操作。sizeCtl：控制标识符，用来控制 table 初始化和扩容操作的。负数代表正在进行初始化或扩容操作，-1 代表正在初始化，-N 表示有 N-1 个线程正在进行扩容操作，正数或 0 代表 hash 表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小")])]),t._v(" "),a("h3",{attrs:{id:"重要操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重要操作"}},[t._v("#")]),t._v(" 重要操作")]),t._v(" "),a("h4",{attrs:{id:"inittable"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#inittable"}},[t._v("#")]),t._v(" initTable")]),t._v(" "),a("p",[t._v("ConcurrentHashMap 初始化方法，只能有一个线程参与初始化过程，其他线程必须挂起。构造函数不做初始化过程，初始化真正是在 put 操作触发。")]),t._v(" "),a("p",[a("strong",[t._v("步骤")]),t._v("：sizeCtl < 0 表示正在进行初始化，线程挂起。线程获取初始化资格（CAS(SIZECTL, sc, -1)）进行初始化过程。初始化步骤完成后，设置 sizeCtl = 0.75 * n（下一次扩容阈值），表示下一次扩容的大小")]),t._v(" "),a("h4",{attrs:{id:"put"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#put"}},[t._v("#")]),t._v(" put")]),t._v(" "),a("p",[t._v("根据 hash 值计算节点插入在 table 的位置，如果该位置为空，则直接插入，否则插入到链表或者树中。")]),t._v(" "),a("p",[a("strong",[t._v("步骤")]),t._v("：table 为 null，线程进入初始化步骤，如果有其他线程正在初始化，该线程挂起。如果插入的当前 i 位置 为 null，说明该位置是第一次插入，利用 CAS 插入节点即可，插入成功，则调用 addCount 判断是否需要扩容。若插入失败，则继续匹配（自旋）。若该节点的 hash ==MOVED（-1），表示有线程正在进行扩容，则进入扩容进程中。其余情况就是按照链表或者红黑树结构插入节点，但是这个过程需要加锁（synchronized）")]),t._v(" "),a("h4",{attrs:{id:"get"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get"}},[t._v("#")]),t._v(" get")]),t._v(" "),a("p",[a("strong",[t._v("步骤")]),t._v("：table 为 null 则直接返回 null，否则通过 hash 从链表/红黑树节点获取")]),t._v(" "),a("h4",{attrs:{id:"扩容"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#扩容"}},[t._v("#")]),t._v(" 扩容")]),t._v(" "),a("p",[a("strong",[t._v("步骤")]),t._v("：构建一个 nextTable，其大小为原来大小的两倍，这个步骤是在单线程环境下完成的。将原来 table 里面的内容复制到 nextTable 中，这个步骤是允许多线程操作")]),t._v(" "),a("h4",{attrs:{id:"链表转换为红黑树过程-树化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#链表转换为红黑树过程-树化"}},[t._v("#")]),t._v(" 链表转换为红黑树过程（树化）")]),t._v(" "),a("p",[t._v("所在链表的元素个数达到了阈值 8，则将链表转换为红黑树")]),t._v(" "),a("h2",{attrs:{id:"concurrentlinkedqueue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#concurrentlinkedqueue"}},[t._v("#")]),t._v(" ConcurrentLinkedQueue")]),t._v(" "),a("p",[t._v("ConcurrentLinkedQueue 基于链接节点的无边界的线程安全队列，采用 FIFO 原则对元素进行排序，内部采用 CAS 算法实现。")]),t._v(" "),a("p",[t._v("入队时将入队节点设置成当前队列尾节点的下一个节点。然后更新 tail 节点，在入队列前如果 tail 节点的 next 节点不为空，则将入队节点设置成 tail 节点，如果 tail 节点的 next 节点为空，则将入队节点设置成 tail 的 next 节点，所以 tail 节点不总是尾节点。利用 CAS 操作，一旦发现插队，则重新获取 tail 节点重试。")]),t._v(" "),a("p",[t._v("出队时首先获取 head 节点的元素，并判断 head 节点元素是否为空，如果为空，表示另外一个线程已经进行了一次出队操作将该节点的元素取走，如果不为空，则使用 CAS 的方式将 head 节点的引用设置成 null，如果 CAS 成功，则直接返回 head 节点的元素，如果 CAS 不成功，表示另外一个线程已经进行了一次出队操作更新了 head 节点，导致元素发生了变化，需要重新获取 head 节点。")]),t._v(" "),a("h2",{attrs:{id:"concurrentskiplistmap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#concurrentskiplistmap"}},[t._v("#")]),t._v(" ConcurrentSkipListMap")]),t._v(" "),a("p",[t._v("ConcurrentSkipListMap 采用 CAS 算法实现，基于跳表（SkipList）存储结构，存储顺序为自然有序。")]),t._v(" "),a("p",[t._v("关于跳表的可以到我博客之前的文章查看 "),a("a",{attrs:{href:"https://blog.ixk.me/talking-about-skip-list.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("浅谈跳表"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"concurrentskiplistset"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#concurrentskiplistset"}},[t._v("#")]),t._v(" ConcurrentSkipListSet")]),t._v(" "),a("p",[t._v("采用 ConcurrentSkipListMap 实现")]),t._v(" "),a("h2",{attrs:{id:"copyonwritearraylist"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copyonwritearraylist"}},[t._v("#")]),t._v(" CopyOnWriteArrayList")]),t._v(" "),a("p",[t._v("CopyOnWriteArrayList 采用 Copy-On-Write（写时复制） 机制进行写操作，在读多写少的环境下性能优于加锁。")]),t._v(" "),a("p",[t._v("读取时直接在原始列表上读取，无需加锁。")]),t._v(" "),a("p",[t._v("写入时加锁同时复制一份，并更新元素，然后将更新后的新列表替换掉旧列表。需要注意的是，之所以要复制一份，是因为写入加的锁并不包括读取操作（只保证了写入是同步的），所以为了保证线程安全不能对原列表直接进行操作。")]),t._v(" "),a("h2",{attrs:{id:"copyonwritearrayset"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copyonwritearrayset"}},[t._v("#")]),t._v(" CopyOnWriteArraySet")]),t._v(" "),a("p",[t._v("采用 CopyOnWriteArrayList 实现")])])}),[],!1,null,null,null);r.default=s.exports}}]);