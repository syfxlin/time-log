(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{554:function(a,v,_){"use strict";_.r(v);var e=_(6),t=Object(e.a)({},(function(){var a=this,v=a.$createElement,_=a._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h2",{attrs:{id:"线程状态"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程状态"}},[a._v("#")]),a._v(" 线程状态")]),a._v(" "),_("ul",[_("li",[_("strong",[a._v("新建（NEW）")]),a._v("：表示线程被创建出来还没真正启动的状态，可以认为它是个 Java 内部状态")]),a._v(" "),_("li",[_("strong",[a._v("就绪（RUNNABLE）")]),a._v("：表示该线程已经在 JVM 中执行，当然由于执行需要计算资源，它可能是正在运行，也可能还在等待系统分配给它 CPU 片段，在就绪队列里面排队")]),a._v(" "),_("li",[_("strong",[a._v("阻塞（BLOCKED）")]),a._v("：这个状态和我们前面两讲介绍的同步非常相关，阻塞表示线程在等待 Monitor lock。比如，线程试图通过 synchronized 去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态")]),a._v(" "),_("li",[_("strong",[a._v("等待（WAITING）")]),a._v("：表示正在等待其他线程采取某些操作。一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待（wait），另外的生产者线程去准备任务数据，然后通过类似 notify 等动作，通知消费线程可以继续工作了。Thread.join()也会令线程进入等待状态")]),a._v(" "),_("li",[_("strong",[a._v("计时等待（TIMED_WAIT）")]),a._v("：其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如 wait 或 join 等方法的指定超时版本")]),a._v(" "),_("li",[_("strong",[a._v("终止（TERMINATED）")]),a._v("：不管是意外退出还是正常执行结束，线程已经完成使命，终止运行，也有人把这个状态叫作死亡")])]),a._v(" "),_("p",[a._v("状态切换：")]),a._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/syfxlin/pic/2020/12/20201210133731.png",alt:"状态切换"}})]),a._v(" "),_("h2",{attrs:{id:"threadlocal"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal"}},[a._v("#")]),a._v(" ThreadLocal")]),a._v(" "),_("p",[a._v("ThreadLocal 是一种解决多线程环境下成员变量的问题的方案，但是与线程同步无关。其思路是为每一个线程创建一个单独的变量副本，从而每个线程都可以独立地改变自己所拥有的变量副本，而不会影响其他线程所对应的副本。")]),a._v(" "),_("p",[a._v("ThreadLocal 不是用于解决共享变量的问题的，也不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制。")]),a._v(" "),_("p",[a._v("四个方法：")]),a._v(" "),_("ul",[_("li",[_("code",[a._v("get()")]),a._v("：返回此线程局部变量的当前线程副本中的值。")]),a._v(" "),_("li",[_("code",[a._v("initialValue()")]),a._v("：返回此线程局部变量的当前线程的“初始值”。")]),a._v(" "),_("li",[_("code",[a._v("remove()")]),a._v("：移除此线程局部变量当前线程的值。")]),a._v(" "),_("li",[_("code",[a._v("set(T value)")]),a._v("：将此线程局部变量的当前线程副本中的值设置为指定值。")])]),a._v(" "),_("p",[a._v("原理：")]),a._v(" "),_("p",[a._v("每个 Thread 内部都有一个 ThreadLocal.ThreadLocalMap 类型的成员变量，该成员变量用来存储实际的 ThreadLocal 变量副本。")]),a._v(" "),_("p",[a._v("ThreadLocalMap 提供了一种用键值对方式存储每一个线程的变量副本的方法，key 为当前 ThreadLocal 对象，value 则是对应线程的变量副本，是实现线程隔离机制的关键。")]),a._v(" "),_("p",[a._v("存储于 Thread 中的好处是可以在线程销毁的时候一并销毁 ThreadLocalMap，防止不能释放内存导致 OOM。")]),a._v(" "),_("p",[a._v("ThreadLocal 只是一个代理类，通过调用 ThreadLocal 的方法取得 ThreadLocalMap 里的变量副本，从而达到互不影响的效果。")]),a._v(" "),_("p",[a._v("内存泄漏：")]),a._v(" "),_("p",[a._v("需要注意的是 ThreadLocalMap 的 Key 是弱引用，但是 Value 是强引用，只有在线程结束时才会被回收。为了解决这个问题我们需要显示调用 remove()。")])])}),[],!1,null,null,null);v.default=t.exports}}]);