---
title: 原型模式
date: 2020-12-25
categories:
  - 设计模式
tags:
  - 概念
---

## 介绍

**意图**：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

**主要解决问题**：在运行期建立和删除原型。

**实现方式**：利用已有的一个原型对象，快速地生成和原型对象一样的实例。

**关键代码**：

1. 实现克隆操作。
2. 原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些"易变类"拥有稳定的接口。

**优点**：

1. 性能提高。
2. 逃避构造函数的约束。

**缺点**：

1. 配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。

**使用场景**：

1. 资源优化场景。
2. 类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。
3. 通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。

## 代码

[代码](https://github.com/syfxlin/code/blob/master/design-pattern-java/src/main/java/me/ixk/design_pattern/prototype)

## 深拷贝浅拷贝

浅拷贝在拷贝的时候会创建一个和原型对一样的对象，同时将原型对象中的所有属性设置到拷贝对象上，如果值为基本类型，那么拷贝的就是基本类型的值，如果值为引用类型，那么拷贝的就只是这个值引用。这样拷贝会造成拷贝的对象的值更改时，原型对象的属性值也跟着改变。

深拷贝在拷贝的时候会创建一个和原型对一样的对象，同时将原型对象中所有的属性设置到浅拷贝对象上，如果值为基本类型，则拷贝基本类型值，如果值为引用类型则递归进行拷贝。这样拷贝的对象就是独立的对象，修改这个拷贝对象不影响原型对象。
