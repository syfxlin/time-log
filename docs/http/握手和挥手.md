---
title: HTTP - 握手和挥手
date: 2020-09-10
categories:
  - HTTP
tags:
  - 概念
---

## TCP

### 握手

1. 客户端给服务器发送一个 SYN 报文，此时客户端处于 `SYN_SEND` 状态。客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。SYN 报文中的序号（SEQ）是随机的，这样可以防御一些攻击。
2. 服务器收到 SYN 报文之后，会应答一个 SYN+ACK 报文，此时服务器处于 `SYN_RCVD` 的状态。服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
3. 客户端收到 SYN+ACK 报文之后，会回应一个 ACK 报文，此时客户端处于 `ESTABLISHED` 状态，服务端收到 ACK 报文后也更改成 `ESTABLISHED` 状态。客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。
4. 服务器收到 ACK 报文之后，三次握手建立完成。

![三次握手流程图](https://cdn.jsdelivr.net/gh/syfxlin/pic/2020/09/20200910205819.png)

### 挥手

1. 客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 `FIN_WAIT1` 状态。客户端关闭 TCP 连接，等待服务端确认。
2. 服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 `CLOSE_WAIT` 状态。此时的 TCP 处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入 FIN_WAIT2（终止等待 2）状态，等待服务端发出的连接释放报文段。
3. 当服务端觉得连接可以关闭了就给客户端发送 FIN 报文，此时服务端处于 `LAST_ACK` 的状态。
4. 客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。服务端收到 ACK 报文后将状态更改为 CLOSE。

![四次挥手流程图](https://cdn.jsdelivr.net/gh/syfxlin/pic/2020/09/20200910212655.png)

### 状态变迁图

![TCP 状态变迁图](https://cdn.jsdelivr.net/gh/syfxlin/pic/2020/09/20200910212837.png)

> 参考：[面试官，不要再问我三次握手和四次挥手](https://juejin.im/post/6844903958624878606)

## TLS 握手

1. 客户端 hello，客户端通过向服务器发送“问候”消息来发起握手。该消息将包括客户端支持的 TLS 版本，支持的加密套件以及称为“客户端随机”的随机字节字符串。
2. 服务器 hello，为回复客户端 hello 消息，服务器发送一条消息，其中包含服务器的 SSL 证书，服务器选择的加密套件和“服务器随机数”，即服务器生成的另一个随机字节串。
3. 客户端发送公钥加密的预主密钥。
4. 服务器用自己的私钥解密加密的预主密钥。
5. 各自 finished 后立即发送。客户端 finished：客户端发送“完成”消息，该消息已用会话密钥加密。服务器 finished：服务器发送一条用会话密钥加密的“完成”消息。
6. 握手完成，后续通过主密钥加解密

注：TLS 握手是建立在 TCP 连接成功后的，所以在 TLS 握手前还需经过 TCP 握手。

![TLS 握手流程图](https://cdn.jsdelivr.net/gh/syfxlin/pic/2020/09/20200910213455.png)

> 参考：[HTTPS 温故知新（三） —— 直观感受 TLS 握手流程(上)](https://halfrost.com/https_tls1-2_handshake/)

## Websocket 握手

WebSocket 协议实现起来相对简单。它使用 HTTP 协议进行初始握手。成功握手之后，就建立了连接，WebSocket 基本上使用原始 TCP 读取/写入数据。

![Websocket 握手流程图](https://cdn.jsdelivr.net/gh/syfxlin/pic/2020/09/20200910213732.png)
